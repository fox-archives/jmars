// Copyright 2008, Arizona Board of Regents
// on behalf of Arizona State University
// 
// Prepared by the Mars Space Flight Facility, Arizona State University,
// Tempe, AZ.
// 
// This program is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
// 
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
// 
// You should have received a copy of the GNU General Public License
// along with this program.  If not, see <http://www.gnu.org/licenses/>.


package edu.asu.jmars.layer.stamp;

import edu.asu.jmars.Main;
import edu.asu.jmars.ProjObj;
import edu.asu.jmars.ProjObj.Projection_OC;
import edu.asu.jmars.util.*;

import java.awt.Color;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.geom.*;
import java.awt.image.BufferedImage;
import java.io.*;
import java.nio.ByteBuffer;
import java.nio.ByteOrder;
import java.util.HashMap;

public class PDSReader
{
    private static final DebugLog log = DebugLog.instance();
    
    protected byte[] dataBuffer;
    protected int imageBytes;
    protected int sampleCount;
    protected int lineCount;
    protected int qubeOffset;
    protected int spatialSumming;
    
    private static final int BUFF_SIZE = 40960;
    
    protected int imageOffset;
    protected double dataScaleOffset;
    protected double dataScaleFactor;
    
    public PDSReader() {
    	
    }
    
    protected PDSReader(InputStream fin, String newFilename)
    throws IOException
    {
        ByteArrayOutputStream buffer = new ByteArrayOutputStream();
        
        dataBuffer = buffer.toByteArray();
        
        log.println("Determining parameters...");
        
    }
         
    // Returns 24-bit RGB color value at specified pixel location; no alpha
    // component.
    public int getRGB(int x, int y)	throws Exception
    {
		if (x >= sampleCount || y >= lineCount || x < 0 || y < 0)
		    throw new Exception("Invalid location: x=" + x + " y=" + y);
	
		int b = dataBuffer[x + y * sampleCount + imageOffset] & 0xFF;
		return new Color(b, b, b).getRGB();
    }
                    
    
    /**
     * Returns temperature in degrees Kelvin for specified image
     * coordinates.
     *
     * Note: this method is only useful for BTR or PBT images.
     */
    public double getTemp(int x, int y)
    {
        int dataIndex = x + sampleCount * y + imageOffset;
        byte pixelVal = dataBuffer[dataIndex];
        
        // Make sure in calculation below that 'pixelVal' is
        // effectively treated as an unsigned value, 0-255 in range.
        double temp = dataScaleFactor * ((int)(pixelVal & 0xFF)) + dataScaleOffset;
        
        log.println("data index = " + dataIndex + ", temp(K) = " + temp);
        
        return temp;
    }
    
    /**
     * Returns temperature in degrees Kelvin for specified image
     * point; double/float coordinates are converted to integer by
     * simply dropping non-integer portion.
     *
     * Note: this method is only useful for BTR images and PBT images.
     */
    public double getTemp(Point2D imagePt)
    {
        return getTemp( (int)imagePt.getX(), (int)imagePt.getY() );
    }
 
    /**
     * Returns image point corresponding to point specified in
     * HVector coordinate space based on cell coordinate data
     * stored in frameCells array (generated by createImageFrame()
     * using getPoints() ).
     *
     * If point does not lie within the image, null is returned.
     */ 
    public Point2D getImagePt(HVector ptVect, Cell cell, int width, int height)
    {
        Point2D.Double pt = null;
        
        Point2D.Double unitPt = new Point2D.Double();
        
        cell.uninterpolate(ptVect, unitPt);

        pt = new Point2D.Double();
        pt.x = unitPt.x * width;            
        pt.y = ((1 - unitPt.y)) * height;

        // Check whether point falls within cell.
        if (unitPt.x >= 0  &&  unitPt.x <= 1  &&
            unitPt.y >= 0  &&  unitPt.y <= 1  )
        {
            pt = new Point2D.Double();
            pt.x = unitPt.x * width;            
            pt.y = ((1 - unitPt.y)) * height;
            
        } 
        
        return pt;
    }

    HashMap<String,String> labelData = new HashMap<String,String>();  
    
    public void parsePDS(File labelFile, File dataFile) {
    	try {
    		FileReader fileReader = new FileReader(labelFile);
    		BufferedReader labelReader = new BufferedReader(fileReader);
    		
    		while (labelReader.ready()) {
    			String line = labelReader.readLine().trim();
    			
    			if (line.equals("END")) break;
    			
    			if (line.startsWith("/*")) continue;
    			
    			int eqLoc = line.indexOf('=');
    			
    			if (eqLoc<1) {
    				continue;
    			}
    	
    			String key = line.substring(0,eqLoc).trim();
    			String val = line.substring(eqLoc+1).trim();
    			   		
    			while (val.startsWith("\"") && !val.endsWith("\"")) {
    				line = labelReader.readLine().trim();
    				val += " " + line;
    			}
    			
    			while (val.startsWith("{") && !val.endsWith("}")) {
    				line = labelReader.readLine().trim();
    				val += " " + line;
    			}

    			while (val.startsWith("(") && !val.endsWith(")")) {
    				line = labelReader.readLine().trim();
    				val += " " + line;
    			}

    			
    			val=val.replace("\"", "").trim();
    			
    			labelData.put(key, val);
    		}
    	
    		
    		FileInputStream fin = new FileInputStream(dataFile);
            ByteArrayOutputStream buffer = new ByteArrayOutputStream();
            byte[] temp = new byte[BUFF_SIZE];
            
            // Read the entire file into a memory buffer            
                int count;
                while((count = fin.read(temp)) >= 0)
                    buffer.write(temp, 0, count);
            
            dataBuffer = buffer.toByteArray();
    		
            int sampleCount = Integer.parseInt(labelData.get("LINE_SAMPLES"));
            int lines = Integer.parseInt(labelData.get("LINES"));
            
            int bandSize = sampleCount*lines*4;
            
            byte [] latVals=new byte[bandSize];            
            
            byte [] lonVals=new byte[bandSize];

            System.arraycopy(dataBuffer, bandSize*4, lonVals, 0, bandSize);
            System.arraycopy(dataBuffer, bandSize*3, latVals, 0, bandSize);

            ByteBuffer lats= ByteBuffer.wrap(latVals);
            lats.order( ByteOrder.LITTLE_ENDIAN );

            ByteBuffer lons= ByteBuffer.wrap(lonVals);
            lons.order( ByteOrder.LITTLE_ENDIAN );
            
            projectImage(lons, lats, sampleCount, lines);
                                    
    	} catch (Exception e) {
    		e.printStackTrace();
    	}
    	
    }
    
    synchronized BufferedImage projectImage(ByteBuffer lon, ByteBuffer lat, int samples, int lines)
    {        
       Point2D pts[] = new Point2D.Double[4];

//       int tmp = lines;
//       lines=samples;
//       samples=tmp;

       int index = lines*samples*4-4;
       pts[0]=new Point2D.Double(360 - lon.getFloat(index), lat.getFloat(index));

       index = lines*samples*4-samples*4;
       pts[1]=new Point2D.Double(360 - lon.getFloat(index), lat.getFloat(index));

       index=0;
       pts[2]=new Point2D.Double(360 - lon.getFloat(index), lat.getFloat(index));

       index = samples*4-4;
       pts[3]=new Point2D.Double(360 - lon.getFloat(index), lat.getFloat(index));

       Projection_OC po = new ProjObj.Projection_OC(0,0);
              
       Cell cell = new Cell(
               new HVector(pts[0]),
               new HVector(pts[1]),
               new HVector(pts[3]),
               new HVector(pts[2]), po);
       
       Rectangle2D where = cell.getWorldBounds();
               
       // What should this be?
       int renderPPD=2048;
              
       // Determine the size of the projected frame image
       int dstW = (int) Math.ceil(where.getWidth()  * renderPPD);
       int dstH = (int) Math.ceil(where.getHeight() * renderPPD);
        
       BufferedImage dstImage = Util.newBufferedImage(dstW, dstH);
        
       if (dstImage == null) {
           log.aprintln("out of memory");
           return null;
       }
                
       /////// VARIABLES FOR THE for() LOOP BELOW
       // worldPt: Stores a point location in world coordinates
       // srcPt:   Stores a point location in the source image data
       // unitPt: Stores a point location in the unit square
       Point2D.Double worldPt = new Point2D.Double();
       Point srcPt = new Point();
       Point2D.Double unitPt = new Point2D.Double();
       HVector spatialPt = new HVector();
        
       /////// CONSTANTS FOR THE for() LOOP BELOW
       // baseX: Pixel-wise world coordinate origin of the destination
       // baseY: Pixel-wise world coordinate origin of the destination
       double baseX = where.getMinX();
       double baseY = where.getMaxY(); // image y coords run top-down
       double X_ZERO = -0.5 / dstW;
       double Y_ZERO = -0.5 / dstH;
       double X_ONE = 1 + 0.5 / dstW;
       double Y_ONE = 1 + 0.5 / dstH;

       BufferedImage srcImage = StampImageFactory.loadImage("/mars/u/cedwards/crism/data/000051EE_07/2.25_overlay.png");

       int srcWidth = srcImage.getWidth();
       int srcHeight = srcImage.getHeight();
       
       for(int i=0; i<srcWidth; i++)
            for(int j=0; j<srcHeight; j++) {
            	
            	int pixelIndex = j*srcWidth*4+i*4;
            	double pixelLat = lat.getFloat(pixelIndex);
            	double pixelLon = 360-lon.getFloat(pixelIndex);
            	
            	Point2D pixelPt = new Point2D.Double(pixelLon, pixelLat);

//            	pixelPt = po.convSpatialToWorld(pixelPt);
            		
            	HVector pixelVector=new HVector(pixelPt);
            	
            	getImagePt(pixelVector, cell, srcWidth, srcHeight);
            	
                // Destination image coordinate to world coordinates.
                worldPt.x = baseX + (double) i / renderPPD;
                worldPt.y = baseY - (double) j / renderPPD;
                
                // Convert from world coordinates to spatial
                // coordinates at the center of the pixel.
                spatialPt.fromLonLat(
                       po.convWorldToSpatial(worldPt.getX(),
                                                  worldPt.getY())
                );
                
                // Uninterpolate from spatial coordinates to the unit
                // square.
                cell.uninterpolate(spatialPt, unitPt);
                
                if(unitPt.x < 0)
                    if(unitPt.x >= X_ZERO)
                        unitPt.x = 0;
                    else
                        continue;
                else if(unitPt.x > 1)
                    if(unitPt.x <= X_ONE)
                        unitPt.x = 1;
                    else
                        continue;
                
                if(unitPt.y < 0)
                    if(unitPt.y >= Y_ZERO)
                        unitPt.y = 0;
                    else
                        continue;
                else if(unitPt.y > 1)
                    if(unitPt.y <= Y_ONE)
                        unitPt.y = 1;
                    else
                        continue;
                
                // Finally, convert from unit square coordinates to
                // source image pixel coordinates.
                                
               	srcPt.setLocation(
                     (int)(   unitPt.x *(srcImage.getWidth()-1) ) + 0,
                     (int)((1-unitPt.y)*(srcImage.getHeight()-1)) + 0);
                
                // Draw the pixel in the destination buffer!
                try {
                		dstImage.setRGB(i, j, srcImage.getRGB(srcPt.x,
                                srcPt.y));                		
                }
                catch (Exception e) {
                    log.aprintln("exception while drawing pixel at i=" + i + " j=" + j);
                    log.aprintln("srcPt.x = " + srcPt.x + " and srcPt.y = " + srcPt.y);
                    log.aprintln(e);
                    return dstImage;
                }
            }
        
        if (dstImage != null) {
            StampImage.savePngImage("/local/test.png", dstImage);
        }
        
        return dstImage;
       
    }                    
    
    public static void main(String args[]) {
    	try {
    		File labelFile = new File("/mars/u/cedwards/crism/data/000051EE_07/FRT000051EE_07_DE166L_DDR1.LBL");
    	//	File labelFile = new File("/mars/themis/data/mapping/BTR_img/I168XXBTR/I16863004BTR.IMG");
    		File dataFile = new File("/mars/u/cedwards/crism/data/000051EE_07/FRT000051EE_07_DE166L_DDR1.IMG");
    		
    		if (!labelFile.canRead()) {
    			System.out.println("Can't read label file.");
    			return;
    		}

    		if (!dataFile.canRead()) {
    			System.out.println("Can't read data file.");
    			return;
    		}
    		
    		PDSReader pds = new PDSReader();
    		pds.parsePDS(labelFile, dataFile);
    		
    		System.out.println("Everything looks good");
    	} catch (Exception e) {
    		e.printStackTrace();
    	}
    	
    	
    }
    
    
}
